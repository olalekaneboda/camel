[[claimCheck-eip]]
== Claim Check EIP

Available as of Camel 2.21

The Claim Check EIP allows you to replace message content with a claim check (a unique key),
which can be used to retrieve the message content at a later time.

It can also be useful in situations where you cannot trust the information with an outside party; in this case, you can use the Claim Check to hide the sensitive portions of data.

NOTE: The Camel implementation of this EIP pattern stores the message content temporarily in an internal memory store.


// eip options: START
The Claim Check EIP supports 5 options which are listed below:


[width="100%",cols="2,5,^1,2",options="header"]
|===
| Name | Description | Default | Type
| *operation* | *Required* The claim check operation to use. The following operations is supported: Get - Gets (does not remove) the claim check by the given key. GetAndRemove - Gets and remove the claim check by the given key. Set - Sets a new (will override if key already exists) claim check with the given key. Push - Sets a new claim check on the stack (does not use key). Pop - Gets the latest claim check from the stack (does not use key). |  | ClaimCheckOperation
| *key* | To use a specific key for claim check id. |  | String
| *include* | What data to include when merging data back from claim check repository. The following syntax is supported: body - to aggregate the message body headers - to aggregate all the message headers header:pattern - to aggregate all the message headers that matches the pattern. The pattern syntax is documented by: link EndpointHelpermatchPattern(String String). You can specify multiple rules separated by comma. For example to include the message body and all headers starting with foo bodyheader:foo. If the include rule is specified as empty or as wildcard then everything is included. |  | String
| *strategyRef* | To use a custom AggregationStrategy instead of the default implementation. Notice you cannot use both custom aggregation strategy and configure data at the same time. |  | String
| *strategyMethodName* | This option can be used to explicit declare the method name to use when using POJOs as the AggregationStrategy. |  | String
|===
// eip options: END


=== Claim Check Operation

When using this EIP you must specify the operation to use which can be of the following:

* Get - Gets (does not remove) the claim check by the given key.
* GetAndRemove - Gets and remove the claim check by the given key.
* Set - Sets a new (will override if key already exists) claim check with the given key.
* Push - Sets a new claim check on the stack (does not use key).
* Pop - Gets the latest claim check from the stack (does not use key).

When using the `Get`, `GetAndRemove`, or `Set` operation you must specify a key.
These operations will then store and retrieve the data using this key. You can use this to store multiple data in different keys.

The `Push` and `Pop` operations do *not* use a key but stores the data in a stack structure.


=== What data to merge back

The `data` option is used to define what data to merge back when using the `Get` or `Pop` operation. When data is merged back
then its merged using a `AggregationStrategy`. The default strategy uses the `data` option to easily specify what data to merge back.

The `data` option takes a String value with the following syntax:

* body - to aggregate the message body
* headers - to aggregate all the message headers
* header:pattern - to aggregate all the message headers that matches the pattern.

The pattern rule supports wildcard and regular expression:

* wildcard match (pattern ends with a * and the name starts with the pattern)
* regular expression match

You can specify multiple rules separated by comma.

For example to include the message body and all headers starting with _foo_:

[text]
----
body,header:foo*
----

To only merge back the message body:

[text]
----
body
----

To only merge back headers:

[text]
----
headers
----

To only merge back a header name foo:

[text]
----
header:foo
----

If the data rule is specified as empty or as wildcard then everything is merged.

Notice that when merging back data, then any existing data is overriden, and any other existing data is preserved.


=== Java Examples

The following example shows the `Push` and `Pop` operations in action;

[java]
----
from("direct:start")
    .to("mock:a")
    .claimCheck(ClaimCheckOperation.Push)
    .transform().constant("Bye World")
    .to("mock:b")
    .claimCheck(ClaimCheckOperation.Pop)
    .to("mock:c");
----

For example if the message body from the beginning is `Hello World` then that data is pushed on the stack of the Claim Check EIP.
And then the message body is transformed to `Bye World`, which is what `mock:b` endpoint receives. When we `Pop` from the Claim Check EIP
then the original message body is retrieved and merged back so `mock:c` will retrieve the message body with `Hello World`.

Here is an example using `Get` and `Set` operations, which uses the key `foo`:

[java]
----
from("direct:start")
    .to("mock:a")
    .claimCheck(ClaimCheckOperation.Set, "foo")
    .transform().constant("Bye World")
    .to("mock:b")
    .claimCheck(ClaimCheckOperation.Get, "foo")
    .to("mock:c")
    .transform().constant("Hi World")
    .to("mock:d")
    .claimCheck(ClaimCheckOperation.Get, "foo")
    .to("mock:e");
----

Notice how we can `Get` the same data twice using the `Get` operation as it will not remove the data. If you only want
to get the data once, you can use `GetAndRemove`.

The last example shows how to use the `data` option where we only want to get back header named `foo` or `bar`:

[java]
----
from("direct:start")
    .to("mock:a")
    .claimCheck(ClaimCheckOperation.Push)
    .transform().constant("Bye World")
    .setHeader("foo", constant(456))
    .removeHeader("bar")
    .to("mock:b")
    // only merge in the message headers foo or bar
    .claimCheck(ClaimCheckOperation.Pop, null, "header:(foo|bar)")
    .to("mock:c");
----

=== XML examples

The following example shows the `Push` and `Pop` operations in action;

[xml]
----
<route>
  <from uri="direct:start"/>
  <to uri="mock:a"/>
  <claimCheck operation="Push"/>
  <transform>
    <constant>Bye World</constant>
  </transform>
  <to uri="mock:b"/>
  <claimCheck operation="Pop"/>
  <to uri="mock:c"/>
</route>
----

For example if the message body from the beginning is `Hello World` then that data is pushed on the stack of the Claim Check EIP.
And then the message body is transformed to `Bye World`, which is what `mock:b` endpoint receives. When we `Pop` from the Claim Check EIP
then the original message body is retrieved and merged back so `mock:c` will retrieve the message body with `Hello World`.

Here is an example using `Get` and `Set` operations, which uses the key `foo`:

[xml]
----
<route>
  <from uri="direct:start"/>
  <to uri="mock:a"/>
  <claimCheck operation="Set" key="foo"/>
  <transform>
    <constant>Bye World</constant>
  </transform>
  <to uri="mock:b"/>
  <claimCheck operation="Get" key="foo"/>
  <to uri="mock:c"/>
  <transform>
    <constant>Hi World</constant>
  </transform>
  <to uri="mock:d"/>
  <claimCheck operation="Get" key="foo"/>
  <to uri="mock:e"/>
</route>
----

Notice how we can `Get` the same data twice using the `Get` operation as it will not remove the data. If you only want
to get the data once, you can use `GetAndRemove`.

The last example shows how to use the `data` option where we only want to get back header named `foo` or `bar`:

[xml]
----
<route>
  <from uri="direct:start"/>
  <to uri="mock:a"/>
  <claimCheck operation="Push"/>
  <transform>
    <constant>Bye World</constant>
  </transform>
  <setHeader headerName="foo">
    <constant>456</constant>
  </setHeader>
  <removeHeader headerName="bar"/>
  <to uri="mock:b"/>
  <claimCheck operation="Pop" data="header:(foo|bar)"/>
  <to uri="mock:c"/>
</route>
----
